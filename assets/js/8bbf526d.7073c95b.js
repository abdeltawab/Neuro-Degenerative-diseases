"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7622],{9599:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var s=r(4848),t=r(8453);const i={sidebar_label:"tree_hierarchy",title:"analysis.tree_hierarchy"},l=void 0,c={id:"reference/analysis/tree_hierarchy",title:"analysis.tree_hierarchy",description:"merge\\_func",source:"@site/docs/reference/analysis/tree_hierarchy.md",sourceDirName:"reference/analysis",slug:"/reference/analysis/tree_hierarchy",permalink:"/VAME/docs/reference/analysis/tree_hierarchy",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{sidebar_label:"tree_hierarchy",title:"analysis.tree_hierarchy"},sidebar:"docsSidebar",previous:{title:"pose_segmentation",permalink:"/VAME/docs/reference/analysis/pose_segmentation"},next:{title:"umap",permalink:"/VAME/docs/reference/analysis/umap"}},o={},d=[{value:"merge_func",id:"merge_func",level:4},{value:"graph_to_tree",id:"graph_to_tree",level:4},{value:"_traverse_tree_cutline",id:"_traverse_tree_cutline",level:4},{value:"traverse_tree_cutline",id:"traverse_tree_cutline",level:4},{value:"bag_nodes_by_cutline",id:"bag_nodes_by_cutline",level:4}];function a(e){const n={code:"code",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h4,{id:"merge_func",children:"merge_func"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def merge_func(transition_matrix: np.ndarray, n_clusters: int,\n               motif_norm: np.ndarray,\n               merge_sel: int) -> Tuple[np.ndarray, np.ndarray]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Merge nodes in a graph based on a selection criterion."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"transition_matrix"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The transition matrix of the graph."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"n_clusters"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The number of clusters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"motif_norm"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The normalized motif matrix."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"merge_sel"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The merge selection criterion."]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Merge nodes with highest transition probability."}),"\n",(0,s.jsx)(n.li,{children:"1: Merge nodes with lowest cost."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Tuple[np.ndarray, np.ndarray]"}),": A tuple containing the merged nodes."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"graph_to_tree",children:"graph_to_tree"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def graph_to_tree(motif_usage: np.ndarray,\n                  transition_matrix: np.ndarray,\n                  n_clusters: int,\n                  merge_sel: int = 1) -> nx.Graph\n"})}),"\n",(0,s.jsx)(n.p,{children:"Convert a graph to a tree."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"motif_usage"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The motif usage matrix."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"transition_matrix"})," (",(0,s.jsx)(n.code,{children:"np.ndarray"}),"): The transition matrix of the graph."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"n_clusters"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The number of clusters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"merge_sel"})," (",(0,s.jsx)(n.code,{children:"int, optional"}),"): The merge selection criterion. Defaults to 1."]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Merge nodes with highest transition probability."}),"\n",(0,s.jsx)(n.li,{children:"1: Merge nodes with lowest cost."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nx.Graph"}),": The tree."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"_traverse_tree_cutline",children:"_traverse_tree_cutline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def _traverse_tree_cutline(\n        T: nx.Graph,\n        node: List[str],\n        traverse_list: List[str],\n        cutline: int,\n        level: int,\n        community_bag: List[List[str]],\n        community_list: List[str] | None = None) -> List[List[str]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"DEPRECATED in favor of bag_nodes_by_cutline.\nHelper function for tree traversal with a cutline."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"T"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The tree to be traversed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"node"})," (",(0,s.jsx)(n.code,{children:"List[str]"}),"): Current node being traversed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"traverse_list"})," (",(0,s.jsx)(n.code,{children:"List[str]"}),"): List of traversed nodes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cutline"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The cutline level."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"level"})," (",(0,s.jsx)(n.code,{children:"int"}),"): The current level in the tree."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"community_bag"})," (",(0,s.jsx)(n.code,{children:"List[List[str]]"}),"): List of community bags."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"community_list"})," (",(0,s.jsx)(n.code,{children:"List[str], optional"}),"): List of nodes in the current community bag."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[List[str]]"}),": List of lists community bags."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"traverse_tree_cutline",children:"traverse_tree_cutline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def traverse_tree_cutline(T: nx.Graph,\n                          root_node: str | None = None,\n                          cutline: int = 2) -> List[List[str]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"DEPRECATED in favor of bag_nodes_by_cutline.\nTraverse a tree with a cutline and return the community bags."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"T"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The tree to be traversed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"root_node"})," (",(0,s.jsx)(n.code,{children:"str, optional"}),"): The root node of the tree. If None, traversal starts from the root."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cutline"})," (",(0,s.jsx)(n.code,{children:"int, optional"}),"): The cutline level."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[List[str]]"}),": List of community bags."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"bag_nodes_by_cutline",children:"bag_nodes_by_cutline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def bag_nodes_by_cutline(tree: nx.Graph, cutline: int = 2, root: str = "Root")\n'})}),"\n",(0,s.jsx)(n.p,{children:"Bag nodes of a tree by a cutline."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"tree"})," (",(0,s.jsx)(n.code,{children:"nx.Graph"}),"): The tree to be bagged."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"cutline"})," (",(0,s.jsx)(n.code,{children:"int, optional"}),"): The cutline level. Defaults to 2."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"root"})," (",(0,s.jsx)(n.code,{children:"str, optional"}),"): The root node of the tree. Defaults to 'Root'."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List[List[str]]"}),": List of bags of nodes."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>c});var s=r(6540);const t={},i=s.createContext(t);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);